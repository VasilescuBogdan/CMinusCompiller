/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal 			ELSE, IF, INT, RETURN, VOID, WHILE, DIV, LOWER, LOWER_EQUAL;
terminal 			BIGGER, BIGGER_EQUAL, EQUAL, NOT_EQUAL, ASSIGN, COLON;
terminal			LPARENR, RPARENR, LPARENS, RPARENS, LBRACE, RBRACE;  
terminal            SEMI, PLUS, MINUS, TIMES;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal      		ID;

/* Non terminals */

non terminal program, declaration_list, declaration, var_declaration, fun_declaration, type_specifier;
non terminal params, param_list, param, compound_stmt, local_declarations, statement_list, statement;
non terminal expression_stmt, selection_stmt, iteration_stmt, return_stmt, expression, var, simple_expression;
non terminal additive_expression, relop, addop, term, mulop, factor, call, args, arg_list; 

/* Precedences */
//precedence nonassoc ELSE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;

/* The grammar rules */

program ::= declaration_list	{: System.out.println("program-> Declaration List \n"); :}
		  ;

declaration_list ::= declaration_list declaration 	{:System.out.println( "declaration_list -> Declaration List Declaration \n");:}
				   | declaration	{:System.out.println( "declaration_list -> declaration\n");:}
				   ;

declaration ::= var_declaration		{: :} 
			  | fun_declaration		{: System.out.println( "declaration -> fun_declaration\n"); :}
			  ;

var_declaration ::= type_specifier ID SEMI 		{::}
			      | type_specifier ID LPARENR NUMBER RPARENR SEMI {::}
			      ;

type_specifier ::= INT 		{::}
				 | VOID     {::}
				 ;
				 
fun_declaration ::= type_specifier ID LPARENR params RPARENR compound_stmt	{::}
				  ;

params ::= param_list	{:	System.out.println("PARAM LIST\n");	:} 
		 | VOID			
		 ;
		 
param_list ::= param_list COLON param 	{::}
			 | param	{: System.out.println("PARAMETER\n");:}
			 ;

param ::= type_specifier ID 	{::}
		| type_specifier ID LPARENR RPARENR		{::}
		;

compound_stmt ::= LBRACE local_declarations statement_list RBRACE		{::}
			    ;

local_declarations ::= local_declarations var_declaration		{::} 
					 | 
					 ;

statement_list ::= statement_list statement		{::} 
				 | 
				 ; 	     

statement ::= expression_stmt	{::} 
			| compound_stmt 	{::}
			| selection_stmt 	{::}
			| iteration_stmt 	{::}
			| return_stmt       {::}
			;		

expression_stmt ::= expression SEMI		{::} 
				  | SEMI				{::}
				  ;


selection_stmt ::= IF LPARENR expression RPARENR statement		{::} 
				 | IF LPARENR expression RPARENR statement ELSE statement		{::}
				 ;

iteration_stmt ::= WHILE LPARENR expression RPARENR statement		{::}
				 ;

return_stmt ::= RETURN SEMI 	{::}
			  | RETURN expression SEMI		{::}
			  ;

expression ::= var ASSIGN expression 	{::}
			 | simple_expression	{::}
			 ;

var ::= ID 		{::}
	  | ID LPARENS expression RPARENS	{::}
	  ;

simple_expression ::= additive_expression relop additive_expression		{::} 
					| additive_expression		{::}
					;

relop ::= LOWER_EQUAL	{::} 
		| LOWER 	{::}
		| BIGGER 	{::}
		| BIGGER_EQUAL 		{::}
		| EQUAL 	{::}
		| NOT_EQUAL		{::}
		;

additive_expression ::= additive_expression addop term		{::} 
					  | term	{::}
					  ;

addop ::= PLUS 		{::}
		| MINUS		{::}
		;

term ::= term mulop factor	{::} 
	   | factor		{::}
	   ;

mulop ::= TIMES		{::} 
		| DIV		{::}
		;

factor ::= LPARENR expression RPARENR	{::} 
		 | var 		{::}
		 | call 	{::}
		 | NUMBER	{::}
		 ;

call ::= ID LPARENR args RPARENR	{::}
	   ;

args ::= arg_list	{::} 
	   | 			{::}
	   ;

arg_list ::= arg_list COLON expression		{::} 
		   | expression						{::}
		   ;








